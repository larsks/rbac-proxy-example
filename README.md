This repository contains two examples of using [`kube-rbac-proxy`][krp] to protect an HTTP resource.

[krp]: https://github.com/brancz/kube-rbac-proxy

In both examples, a `producer` service offers an HTTP endpoint (`http://producer/example`). A `consumer` periodically reads from this endpoint. We use `kube-rbac-proxy` to authenticate the consumer and grant access to the resource.

## Viewing the manifests

To view the manifests without deploying them, use `kubectl kustomize`; for example, to view the `token-auth` example, run:

```
kubectl kustomize overlays/token-auth
```

## Managing certificates

This repository sets up an internal certificate authority using [cert-manager][]. This allows us to generate certificate on the fly that are trusted by both the `consumer` and the `producer`. This is effectively following the example [from the documentation on SelfSigned issuers][selfsigned].

[cert-manager]: https://cert-manager.io/
[selfsigned]: https://cert-manager.io/docs/configuration/selfsigned/

## Authentication

In both examples, we bind a security principal to a ClusterRole that [grants access to the `/example` HTTP endpoint][consumer-cr].

[consumer-cr]: base/consumer/consumer-cr.yaml

### Token authentication

In the manifests generated by [`overlays/token-auth`][token-auth], the `consumer` authenticates to the `producer` using a ServiceAccount token.

[token-auth]: overlays/token-auth

### Mutual TLS

In [`overlays/mutual-tls`][mtls], we use a certificate for authentication instead of a ServiceAccount token. The certificate must be signed by an authority that is trusted by `kube-rbac-proxy` (as configured by the `--client-ca-file` option). The CommonName of the certificate is interpreted as a user in order to perform an RBAC lookup, so while our policy uses the same  ClusterRole, we're matching a User instead of a ServiceAccount.

[mtls]: overlays/mutual-tls

## Viewing results

After deploying one of the overlays, watch the logs from the `consumer` deployment:

```
kubectl logs deploy/consumer
```
