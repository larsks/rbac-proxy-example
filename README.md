This repository contains two examples of using [`kube-rbac-proxy`][krp] to protect an HTTP resource.

[krp]: https://github.com/brancz/kube-rbac-proxy

In both examples, a `producer` service offers an HTTP endpoint (`http://producer/example`). A `consumer` periodically reads from this endpoint. We use `kube-rbac-proxy` to authenticate the consumer and grant access to the resource.

## Managing certificates

This repository sets up an internal certificate authority using [cert-manager][]. This allows us to generate certificate on the fly that are trusted by both the `consumer` and the `producer`. This is effectively following the example [from the documentation on SelfSigned issuers][selfsigned].

[cert-manager]: https://cert-manager.io/
[selfsigned]: https://cert-manager.io/docs/configuration/selfsigned/

## Authentication

### Token authentication

In the manifests generated by `overlays/token-auth`, the `consumer` authenticates to the `producer` using a ServiceAccount token. We grant the ServiceAccount access to the `producer` endpoint by [binding the ServiceAccount][token-crb] to a [ClusterRole that grants access to the `/example` endpoint][token-cr].

[token-cr]: overlays/token-auth/consumer/consumer-cr.yaml
[token-crb]: overlays/token-auth/consumer/consumer-crb.yaml

### Mutual TLS

In `overlays/mutual-tls`, we use a certificate for authentication instead of a ServiceAccount token. The certificate must be signed by an authority that is trusted by `kube-rbac-proxy` (as configured by the `--client-ca-file` option). The CommonName of the certificate is interpreted as a user in order to perform an RBAC lookup, so while our policy uses [the same  ClusterRole][mtls-cr], we update the policy to [use a User instead of a ServiceAccount][mtls-crb].

[mtls-cr]: overlays/mutual-tls/consumer/consumer-cr.yaml
[mtls-crb]: overlays/mutual-tls/consumer/consumer-crb.yaml

## Viewing results

After deploying one of the overlays, watch the logs from the `consumer` deployment:

```
kubectl logs deploy/consumer
```
